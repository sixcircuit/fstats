"use strict";

var _ = require('dry-underscore');

function fstats(options){
    options = options || {};
    var root = options.root || _.path.cwd();

    this._root = root;
    this._read_only = (options.read_only === true);

    this.root = _.path.fun(_.path.normalize(root));

    this._history = [];

    this._storage_file_path = this.root(".fstats.json");

    this._stats = {};
}

fstats.prototype.stats = _.rk("_stats");
fstats.prototype.history = _.rk("_history");
fstats.prototype.last_run = function(){ return(_.first(this.history())); }

fstats.prototype.load_history = function(callback){
    if(this._read_only){ return callback(); }

    await{ _.fs.read_json(this._storage_file_path, _.plumb(defer(var err, history), callback, _.code.noent)); }
    if(err){  this._history = []; }
    else{ this._history = history; }
    return callback(null);
};

fstats.prototype.save_history = function(callback){
    if(this._read_only){ return callback(); }

    await{ _.fs.write_json(this._storage_file_path, this.history(), _.plumb(defer(), callback)); }
    callback(null);
};

fstats.prototype.add_last_run = function(key, human_stat, to_human){

    var last_run = this.last_run();

    if(last_run && last_run[key] !== null && last_run[key] !== undefined){
        human_stat.last_run = { value : { raw: last_run[key] } };
        human_stat.last_run.value.human = to_human(last_run[key]);
        human_stat.last_run.change = { raw: _.round(human_stat.current.value.raw - last_run[key], 2) };
        human_stat.last_run.change.human = to_human(human_stat.last_run.change.raw);
    }else{
        human_stat.last_run = null;
    }
};

fstats.prototype.add_max_run = function(key, raw_stats, human_stat, to_human){

    var history = _.concat(raw_stats, this.history());

    var max_run = _.max(history, function(raw_stat){ return(raw_stat[key] || 0); });

    if(max_run && max_run[key] !== null && max_run[key] !== undefined){
        human_stat.max_run = { value : { raw: max_run[key] } };
        human_stat.max_run.value.human = to_human(max_run[key]);
        human_stat.max_run.change = { raw: _.round(human_stat.current.value.raw - max_run[key], 2) };
        human_stat.max_run.change.human = to_human(human_stat.max_run.change.raw);
    }else{
        human_stat.max_run = null;
    }
};


fstats.prototype.add_value = function(key, raw_stats, to_human){
    var human_stat = { current: { value: { raw: raw_stats[key] } } };

    to_human = to_human || function(num){ return(_.format.number(num, { max: 2 })); };

    human_stat.current.value.human = to_human(human_stat.current.value.raw); 

    this.add_last_run(key, human_stat, to_human);
    this.add_max_run(key, raw_stats, human_stat, to_human);

    this._stats[key] = human_stat;

    return(this._stats[key]);
};

fstats.prototype.add_byte_value = function(key, raw_stats){
    var human_stat = this.add_value(key, raw_stats, _.byte_units);
    return(human_stat);
};

fstats.prototype.update_stats = function(raw_stats, callback){

    raw_stats.timestamp = _.timestamp();

    raw_stats.files_per_dir = raw_stats.file_count / (raw_stats.dir_count + 1);

    this.add_value("file_count", raw_stats);
    this.add_value("dir_count", raw_stats);
    this.add_value("link_count", raw_stats);
    this.add_value("files_per_dir", raw_stats);
    this.add_byte_value("allocated", raw_stats);
    this.add_byte_value("size", raw_stats);

    this._history.unshift(raw_stats);

    return this.save_history(callback);
};

fstats.prototype.compute = function(callback){
    var self = this;

    this._stats = {};

    var raw_stats = {
        dir_count: 0,
        file_count: 0,
        link_count: 0,
        size: 0,
        allocated: 0,
    };

    await{ this.load_history(_.plumb(defer(), callback)); }

    _.fs.walk(self.root(), { lstat: true }, function on_file(file_info, next){
        if(file_info.stat.isSymbolicLink()){ raw_stats.link_count++; }
        var stat = file_info.stat;
        raw_stats.file_count++;
        raw_stats.size += stat.size;
        raw_stats.allocated += (stat.blocks * 512);
        next();
    }, function on_dir(dir_info, next){
        raw_stats.dir_count++;
        next();
    }, function(err){
        if(err){ return callback(err); }

        await{ self.update_stats(raw_stats, _.plumb(defer(), callback)); }

        return callback(null, self.stats());
    });
};


module.exports = function(options){ return(new fstats(options)); };
